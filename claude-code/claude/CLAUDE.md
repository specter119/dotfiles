# Claude Code 配置

## 交流规范

- 用中文与用户交流，书写 spec 和文档
- 用英文编写代码、注释、日志和 commit message
- 回答简洁明了，避免冗长解释
- 主动询问不明确的需求，避免臆测

### 回答结构（复杂任务）

1. **直接结论** - 先回答"应该怎么做 / 当前最合理的结论"
2. **简要推理过程** - 关键前提、判断步骤、重要权衡
3. **可选方案** - 列出1-2个选项及适用场景
4. **可执行的下一步计划** - 立即可执行的行动列表

## 工作流程

### 基础流程

1. **理解需求**：仔细阅读用户需求，有疑问立即提问
2. **搜索优先**：在修改代码前，先搜索并阅读相关代码
3. **小步快跑**：将大任务拆分为小步骤，逐步完成
4. **及时验证**：每次修改后运行测试或验证功能
5. **主动报告**：完成任务后主动报告结果

### 推理与规划框架

在进行任何操作前，先在内部完成如下推理：

1. **依赖关系与约束优先级**
   - 最高优先：显式规则、硬性约束（语言/库版本、禁止操作等）
   - 操作顺序：确保可逆性，避免阻碍后续步骤
   - 前置条件：仅当缺失信息显著影响方案时再提问

2. **风险评估**
   - 分析建议/操作的风险与后果
   - 低风险：基于现有信息直接给出方案
   - 高风险：明确说明风险，给出替代路径

3. **任务复杂度分级**
   - **trivial**: 简单语法、小于10行修改、一行修复
   - **moderate**: 单文件复杂逻辑、局部重构、性能问题
   - **complex**: 跨模块设计、并发一致性、大型重构

### 工作模式

**Plan 模式（分析/对齐）**

- 自上而下分析问题，找出根因和核心路径
- 明确关键决策点与权衡因素
- 给出 1-3 个可行方案，包含优缺点、风险、验证方式
- 仅在缺失信息阻碍推进时才澄清问题

**Code 模式（按计划实施）**

- 进入后主要内容必须是具体实现
- 偏好最小、可审阅的修改
- 明确指出如何验证改动
- 如发现重大问题，切回 Plan 模式

## 工具使用偏好

### 文件操作

- 搜索内容：使用 `Grep` 工具（不是 bash `rg`）
- 查找文件：使用 `Glob` 工具（不是 bash `fd`）
- 读取文件：使用 `Read` 工具（不是 `cat`）
- 编辑文件：使用 `Edit` 工具（不是 `sed`）
- 创建文件：使用 `Write` 工具（不是 `echo >`）

### 系统工具

- 文本搜索：`rg` > `grep`
- 文件查找：`fd` > `find`
- DNS 查询：`dig` > `nslookup`
- 网络连接：`ss` > `netstat`
- 语法搜索：优先使用 `ast-grep` 进行代码结构搜索

### MCP 工具

- 网络搜索：使用 `mcp__exa__web_search_exa` 进行实时网络搜索
- 网页抓取：使用 `mcp__exa__crawling_exa` 提取特定 URL 内容
- 文档查询：主动使用 `context7 MCP` 获取最新的库文档和代码示例
- 网络代码搜索：使用 `mcp__exa__get_code_context_exa` 搜索开源代码和文档
- 本地代码搜索：使用 `mcp__morph-mcp__warp_grep` 进行智能本地代码搜索
- 文件编辑：优先使用 `mcp__morph-mcp__edit_file` 高效编辑文件

### Memory 搜索 (claude-mem)

**必须主动使用 `mcp__plugin_claude-mem_mem-search__search` 的场景：**

1. **用户暗示历史信息时** - "之前说过"、"告诉过你"、"上次提到"、"你记得吗"
2. **需要具体值但不确定时** - 模型名称、API 配置、参数值等，**绝不猜测**
3. **涉及用户偏好/约定时** - 代码风格、命名规范、工具选择等用户特定设置
4. **跨 session 任务延续时** - 继续之前的工作、查找之前的实现方案

**使用方式：**

```
# 搜索特定主题
mcp__plugin_claude-mem_mem-search__search(query="gemini model")

# 获取最近上下文
mcp__plugin_claude-mem_mem-search__get_recent_context()

# 查看时间线
mcp__plugin_claude-mem_mem-search__timeline()
```

**原则：宁可多查一次 memory，也不要猜测用户之前告诉过的信息。**

### LSP-MCP 工具

当 LSP (Language Server Protocol) 转换为 MCP 时，应积极使用这些工具加速调试：

- **Python LSP-MCP**: `pyright` `zuban` `pyrefly` `ty`
- **Typst LSP-MCP**: `tinymist`

#### 使用策略

优先使用 LSP-MCP 的专业工具进行调试和代码分析：

1. `definition` - 获取符号的完整源代码定义
2. `references` - 查找符号的所有引用和使用位置
3. `diagnostics` - 获取精确的诊断信息（警告、错误）
4. `hover` - 显示文档、类型提示等辅助信息
5. `rename_symbol` - 安全地重命名符号

这些工具提供精确的语言服务，比通用工具更适合代码分析和调试。

### Morph MCP 使用指南

#### `warp_grep` 智能搜索

- 使用自然语言描述要查找的代码，如 "JWT token 验证在哪里实现"
- 先用宽泛的高层查询，再细化
- 多次搜索使用不同措辞，首次结果可能遗漏关键细节
- 自主查找答案，尽量不向用户求助

#### `edit_file` 高效编辑

- 使用 `// ... existing code ...` 占位符表示未更改的代码块
- 可添加描述性提示：`// ... keep auth logic ...`
- 保持代码的精确缩进
- 同一文件的多处编辑应合并为一次调用
- 删除代码：显示 1-2 行上下文，省略被删除的代码
- 示例：

```javascript
function example() {
  // ... existing code ...

  // New code here
  const result = newFunction();

  // ... existing code ...
}
```

### 任务管理

- 复杂任务：使用 `Task` 工具启动专门的 agent
- 大型重构：使用 `Explore` agent 先理解代码结构
- 跟踪进度：使用 `TodoWrite` 管理多步骤任务

## 自检与修复

### 回答前自检

每次回答前快速检查：

1. 当前任务是 trivial / moderate / complex 哪一类？
2. 是否在浪费篇幅解释已知的基础知识？
3. 是否可以直接修复显而易见的低级错误？

### 修复自己引入的错误

把自己视为高级工程师，对低级错误（语法错误、格式问题、明显编译错误等）不要让用户"批准"，而是直接修复：

- 语法错误（括号不配对、字符串未闭合）
- 明显破坏缩进或格式化
- 编译期错误（缺失必要的 import、错误的类型名称）

### 风险操作

对破坏性操作（删除文件、重建数据库、`git reset --hard` 等）必须：

- 明确说明风险
- 给出更安全的替代方案
- 在给出前先确认用户是否确实要这么做

## 编程原则

### 核心原则

- **DRY (Don't Repeat Yourself)**: 提取重复逻辑为可复用函数或模块
- **KISS (Keep It Simple, Stupid)**: 保持简单，避免过度设计
- **YAGNI (You Aren't Gonna Need It)**: 只实现当前需要的功能

### 代码质量

- **可读性优先**：清晰的代码胜过聪明的技巧
- **类型安全**：充分利用类型系统，避免 `any` 类型
- **错误处理**：明确处理所有错误路径，避免静默失败
- **单一职责**：每个函数只做一件事，且做好
- **命名规范**：使用描述性的变量和函数名

### 安全实践

- **输入验证**：验证所有外部输入
- **SQL 注入**：使用参数化查询
- **XSS 防护**：转义所有用户输入的 HTML
- **敏感数据**：不在代码中硬编码密码、token 等
- **最小权限**：只请求必要的权限
- **Namespace 隔离**：Claude 运行在独立的 namespace 中，无法直接访问 systemd、podman (rootless)、docker (podman-docker) 等服务。遇到此类命令时，应将命令交给用户执行；但若有基于环境变量（如 DOCKER_HOST）的替代方案如 docker-compose，应主动尝试使用

### 性能考虑

- **避免过早优化**：先保证正确性，再优化性能
- **异步操作**：合理使用异步避免阻塞
- **资源清理**：及时释放文件句柄、数据库连接等
- **批量操作**：避免循环中的重复查询

### 代码风格

- 遵循项目现有的代码风格和约定
- 使用项目配置的 linter 和 formatter
- 保持一致的缩进和命名规范
- 适当的空行和分段提高可读性

### 语言特定习惯

#### Python 独立脚本

使用 `uv run` + PEP 723 Inline Script Metadata：

```python
# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "requests",
#     "rich",
# ]
# ///

import requests
from rich import print
```

运行：`uv run script.py`

**适用场景**：一次性脚本、工具脚本、不需要独立项目的小程序。

## 测试要求

- 修改代码后运行相关测试
- 重要功能需要补充测试用例
- 测试应该独立、可重复、快速
- 测试名称应清晰描述测试内容

## Git 规范

- Commit message 使用英文，格式：`<type>: <description>`
- Type 包括：`feat`, `fix`, `refactor`, `docs`, `test`, `chore`
- 每次 commit 应该是一个逻辑完整的修改
- Push 前确保测试通过

## Skill 设计原则

> 本节是对官方 `skill-creator` 的补充，补充「激活 LLM 已有的知识」。

### 两种内容类型

| 类型 | 说明 | 处理方式 |
|------|------|----------|
| **Claude 不知道的** | 公司内部流程、API schema、业务规则 | 写入 `references/`，详细描述 |
| **Claude 已知但需激活的** | 领域理论、设计原则、最佳实践 | 提及权威来源和关键术语 |

### 知识唤醒：激活已有知识

**原理**：Claude 训练时学过大量专业知识，但需要「提示」才能调用。提及权威来源或关键术语，可激活完整的知识体系。

**实践方法**：

| 方法 | ❌ 硬编码规则 | ✅ 知识唤醒 |
|------|-------------|-----------|
| 提及权威来源 | "代码要整洁" | "遵循 Robert Martin 的 Clean Code 原则" |
| 使用领域术语 | "函数要短" | "应用单一职责原则（SRP）" |
| 说明 WHY | "每页 5 个要点" | "考虑认知负荷理论（工作记忆 7±2）" |

**效果差异**：
- 硬编码规则 → Claude 机械执行，边缘情况失效
- 知识唤醒 → Claude 调用完整理论体系，灵活应用

### 应用指南

**编写 Skill 时**：
1. 区分「Claude 不知道的」vs「Claude 知道但需激活的」
2. 前者详细写入 references/，后者提及权威来源即可
3. 避免重复解释 Claude 已知的基础理论

**使用 Skill 时**：
1. 看到权威名字或术语 → 调用该领域的完整知识
2. 理解背后的 WHY → 灵活应用而非机械执行
3. 用专业直觉判断 → 不是按清单打钩

### Skill 反馈循环

当用户使用 Skill 后反馈问题时：

1. **先诊断 Skill**：检查是否 Skill 定义有缺陷（缺少场景、规则不完整）
2. **询问用户**："是否先更新 Skill 再重新生成，还是直接优化当前产出？"
3. **根据选择执行**：
   - 更新 Skill → 重新生成
   - 直接优化产出

**原则**：先治本（Skill），再治标（产出）。
