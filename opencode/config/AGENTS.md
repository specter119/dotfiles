# Claude Code 配置

## 交流规范

- 用中文交流、写 spec 和文档
- 用英文写代码、注释、日志和 commit message
- 回答简洁，避免冗长解释
- 不明确时主动提问，不臆测

## 工作流程

### 基础流程

1. **理解需求** - 有疑问立即提问
2. **搜索优先** - 修改前先搜索并阅读相关代码
3. **小步快跑** - 拆分大任务，逐步完成
4. **及时验证** - 每次修改后验证
5. **主动报告** - 完成后报告结果

### 推理框架

操作前完成以下推理：

1. **优先级与约束**：显式规则 > 操作顺序 > 前置条件
2. **风险评估**：低风险直接行动，高风险说明替代方案
3. **复杂度分级**：
   - trivial: 简单语法、<10行修改
   - moderate: 单文件复杂逻辑、局部重构
   - complex: 跨模块设计、大型重构

### 工作模式

**Plan 模式（分析/对齐）**

- 自上而下分析根因
- 明确关键决策和权衡
- 给出 1-3 个可行方案
- 仅在信息缺失时提问

**Code 模式（按计划实施）**

- 直接具体实现
- 最小、可审阅的修改
- 明确验证方式
- 发现问题切回 Plan

## 工具使用偏好

### 文件操作

| 操作 | 优先工具 | 避免工具 |
|------|----------|----------|
| 搜索内容 | `Grep` | bash `rg` |
| 查找文件 | `Glob` | bash `fd` |
| 读取文件 | `Read` | `cat` |
| 编辑文件 | `Edit` | `sed` |
| 创建文件 | `Write` | `echo >` |

### 系统工具

- 文本搜索：`rg` > `grep`
- 文件查找：`fd` > `find`
- DNS 查询：`dig` > `nslookup`
- 网络连接：`ss` > `netstat`
- 语法搜索：`ast-grep`

### MCP 工具

**Exa MCP**

- `web_search_exa` - 实时网络搜索
- `crawling_exa` - 抓取 URL 内容
- `get_code_context_exa` - 搜索开源代码

**Morph MCP**

`warp_grep` - 智能本地代码搜索

- 使用自然语言描述，如 "JWT token 验证在哪里实现"
- 先宽泛查询，再细化；多次尝试不同措辞

`edit_file` - 高效编辑

- 使用 `// ... existing code ...` 表示未更改代码
- 可添加描述：`// ... keep auth logic ...`
- 同一文件多处编辑合并为一次调用
- 保持精确缩进

**Context7 MCP**

- 获取最新库文档和代码示例

### 任务管理

- 复杂任务：`Task` 工具启动专门 agent（`general` 或 `explore`）
- 大型重构：`explore` agent 先理解代码结构
- 多步骤任务：`TodoWrite` 跟踪进度

## 自检与修复

### 回答前自检

1. 任务复杂度：trivial / moderate / complex？
2. 是否在解释已知的基础知识？
3. 是否可以直接修复低级错误？

### 自动修复低级错误

直接修复，无需批准：

- 语法错误（括号不配对、字符串未闭合）
- 明显的缩进或格式问题
- 编译期错误（缺失 import、错误类型）

### 风险操作

破坏性操作（删除文件、重建数据库、`git reset --hard`）必须：

- 明确说明风险
- 给出更安全的替代方案
- 确认用户意图

## 回答结构（复杂任务）

1. **直接结论** - 应该怎么做 / 当前最合理的结论
2. **简要推理** - 关键前提、判断步骤、重要权衡
3. **可选方案** - 1-2 个选项及适用场景
4. **下一步计划** - 可执行的行动列表

## 编程原则

### 核心原则

- **DRY** - 提取重复逻辑
- **KISS** - 保持简单
- **YAGNI** - 只实现当前需要的功能

### 代码质量

- 可读性优先 > 聪明的技巧
- 充分利用类型系统，避免 `any`
- 明确处理所有错误路径
- 单一职责：每个函数只做一件事
- 使用描述性的变量和函数名

### 安全实践

- 验证所有外部输入
- 使用参数化查询防 SQL 注入
- 转义用户输入防 XSS
- 不在代码中硬编码密码、token
- 最小权限原则
- **Namespace 隔离**：无法直接访问 systemd、podman、docker。此类命令交给用户执行；若有基于环境变量的替代方案（如 DOCKER_HOST 的 docker-compose），主动尝试

### 性能考虑

- 先保证正确性，再优化性能
- 合理使用异步避免阻塞
- 及时释放资源（文件句柄、数据库连接）
- 批量操作，避免循环中重复查询

## 代码风格

- 遵循项目现有风格和约定
- 使用项目配置的 linter 和 formatter
- 保持一致的缩进和命名
- 适当空行和分段

## 测试要求

- 修改代码后运行相关测试
- 重要功能补充测试用例
- 测试独立、可重复、快速
- 测试名称清晰描述测试内容

## Git 规范

- Commit message：英文，格式 `<type>: <description>`
- Type：`feat`, `fix`, `refactor`, `docs`, `test`, `chore`
- 每次 commit 逻辑完整
- Push 前确保测试通过

## Skill 设计原则

> 本节是对官方 `skill-creator` 的补充，补充「激活 LLM 已有的知识」。

### 两种内容类型

| 类型 | 说明 | 处理方式 |
|------|------|----------|
| Claude 不知道的 | 内部流程、API schema、业务规则 | 详细写入 `references/` |
| Claude 已知但需激活的 | 领域理论、设计原则、最佳实践 | 提及权威来源和关键术语 |

### 知识唤醒：激活已有知识

**原理**：提及权威来源或关键术语，激活完整知识体系。

| 方法 | ❌ 硬编码规则 | ✅ 知识唤醒 |
|------|-------------|-----------|
| 提及权威来源 | "代码要整洁" | "遵循 Robert Martin 的 Clean Code" |
| 使用领域术语 | "函数要短" | "应用单一职责原则（SRP）" |
| 说明 WHY | "每页 5 个要点" | "考虑认知负荷理论（7±2）" |

**效果**：

- 硬编码规则 → 机械执行，边缘情况失效
- 知识唤醒 → 调用完整理论，灵活应用

### 应用指南

**编写 Skill 时**：

1. 区分「不知道的」vs「已知但需激活的」
2. 前者详细写入 `references/`，后者提及权威来源
3. 避免重复解释 Claude 已知的基础理论

**使用 Skill 时**：

1. 看到权威名字或术语 → 调用完整知识
2. 理解背后的 WHY → 灵活应用
3. 用专业直觉判断 → 不是按清单打钩
