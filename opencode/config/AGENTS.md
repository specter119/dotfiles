# AGENTS.md

## 交流规范

- 用中文交流、写 spec 和文档
- 用英文写代码、注释、日志和 commit message
- 回答简洁，避免冗长解释
- 不明确时主动提问，不臆测

### 回答结构（复杂任务）

1. **直接结论** - 应该怎么做 / 当前最合理的结论
2. **简要推理** - 关键前提、判断步骤、重要权衡
3. **可选方案** - 1-2 个选项及适用场景
4. **下一步计划** - 可执行的行动列表

## 工作流程

### 基础流程

1. **理解需求** - 有疑问立即提问
2. **搜索优先** - 修改前先搜索并阅读相关代码
3. **小步快跑** - 拆分大任务，逐步完成
4. **及时验证** - 每次修改后验证
5. **主动报告** - 完成后报告结果

### 推理框架

操作前完成以下推理：

1. **优先级与约束**：显式规则 > 操作顺序 > 前置条件
2. **风险评估**：低风险直接行动，高风险说明替代方案
3. **复杂度分级**：
   - trivial: 简单语法、<10行修改
   - moderate: 单文件复杂逻辑、局部重构
   - complex: 跨模块设计、大型重构

## 工具使用偏好

### 工具偏好

- 文本搜索：`rg` > `grep`
- 文件查找：`fd` > `find`
- DNS 查询：`dig` > `nslookup`
- 网络连接：`ss` > `netstat`
- 语法搜索：`ast-grep`
- 网络搜索：`websearch`；若请求失败，用 `exa_web_search_exa`
- 网页抓取：`webfetch`；若请求失败，用 `exa_crawling_exa`
- PDF 转图片：`pdftoppm`（不要用 Playwright）

> **注意**：PDF 截图 ≠ 浏览器截图。用 `pdftoppm -png -r 150 file.pdf out/page`。
> 每次截图前清理输出目录，避免旧文件残留。

## 自检与修复

### 回答前自检

1. 任务复杂度：trivial / moderate / complex？
2. 是否在解释已知的基础知识？
3. 是否可以直接修复低级错误？

### 自动修复低级错误

直接修复，无需批准：

- 语法错误（括号不配对、字符串未闭合）
- 明显的缩进或格式问题
- 编译期错误（缺失 import、错误类型）

### 风险操作

破坏性操作（删除文件、重建数据库、`git reset --hard`）必须：

- 明确说明风险
- 给出更安全的替代方案
- 确认用户意图

## 编程原则

遵循软件工程基本原则（DRY, KISS, YAGNI, SRP）。

### 语言特定习惯

#### Python API 设计与代码范式

详见 [Friendly Python](./friendly_python.md)：基于 Frost Ming 系列文章整理的 Python 工程实践指南，涵盖：

- 以用户体验倒推 API 设计（合理默认值、上下文管理器）
- 扩展点收敛（注册中心替代 if-else 链）
- 构造方式清晰（classmethod 替代 flag 参数）
- 显式优于隐式（避免 `__getattr__` 滥用）
- 复用生态扩展点（如 `requests.auth.AuthBase`）

#### Python 独立脚本

使用 `uv run` + PEP 723 Inline Script Metadata：

```python
# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "requests",
#     "rich",
# ]
# ///

import requests
from rich import print
```

运行：`uv run script.py`

**适用场景**：一次性脚本、工具脚本、不需要独立项目的小程序。

## 测试要求

- 修改代码后运行相关测试
- 重要功能补充测试用例
- 测试独立、可重复、快速
- 测试名称清晰描述测试内容

## Git 规范

- Commit message：英文，格式 `<type>: <description>`
- Type：`feat`, `fix`, `refactor`, `docs`, `test`, `chore`
- 每次 commit 逻辑完整
- Push 前确保测试通过

## Skill 设计原则

> 本节是对官方 `skill-creator` 的补充，补充「激活 LLM 已有的知识」。

### 两种内容类型

| 类型                 | 说明                           | 处理方式               |
| -------------------- | ------------------------------ | ---------------------- |
| Model 不知道的       | 内部流程、API schema、业务规则 | 详细写入 `references/` |
| Model 已知但需激活的 | 领域理论、设计原则、最佳实践   | 提及权威来源和关键术语 |

### 知识唤醒：激活已有知识

**原理**：提及权威来源或关键术语，激活完整知识体系。

| 方法         | ❌ 硬编码规则   | ✅ 知识唤醒                        |
| ------------ | --------------- | ---------------------------------- |
| 提及权威来源 | "代码要整洁"    | "遵循 Robert Martin 的 Clean Code" |
| 使用领域术语 | "函数要短"      | "应用单一职责原则（SRP）"          |
| 说明 WHY     | "每页 5 个要点" | "考虑认知负荷理论（7±2）"          |

**效果**：

- 硬编码规则 → 机械执行，边缘情况失效
- 知识唤醒 → 调用完整理论，灵活应用

### 应用指南

**编写 Skill 时**：

1. 区分「不知道的」vs「已知但需激活的」
2. 前者详细写入 `references/`，后者提及权威来源
3. 避免重复解释 Model 已知的基础理论

**使用 Skill 时**：

1. 看到权威名字或术语 → 调用完整知识
2. 理解背后的 WHY → 灵活应用
3. 用专业直觉判断 → 不是按清单打钩

### Skill 反馈循环

当用户使用 Skill 后反馈问题时：

1. **先诊断 Skill**：检查是否 Skill 定义有缺陷（缺少场景、规则不完整）
2. **询问用户**："是否先更新 Skill 再重新生成，还是直接优化当前产出？"
3. **根据选择执行**：
   - 更新 Skill → 重新生成
   - 直接优化产出

**原则**：先治本（Skill），再治标（产出）。
